<style type="text/css"><!--
    .axis .domain {
        fill: none;
        stroke: black;
        stroke-width: 0;
        shape-rendering: crispEdges;
    }

	.node circle { fill: #fff; }
	.node.expandable circle { fill: #069; }
    .axis .tick text { font-size: .75rem; }
    .grid-background { fill: #eee; }

--></style>
[%	WRAPPER scripts/pageload_wrapper.tt;
	scr_arr =
	[
		'/js/d3.min.js',
		'/js/d3-tip.js',
		'/js/element-resize-detector.min.js',
		'/js/d3.chart.min.js',
		'/js/d3.chart.base-ext.js',
		'/js/d3.chart.layout.hierarchy-ext.js',
#		'/js/d3.chart.tooltip.js'
	];
%]
/**


        var rightAngleDiagonal = function () {
            var projection = function (d) {
                return [d.y, d.x];
            },

            path = function (pathData) {
                return "M" + pathData[0] + ' ' + pathData[1] + " " + pathData[2] + " " + pathData[3] + " " + pathData[4];
            };

            function diagonal(diagonalPath, i) {
                var source = diagonalPath.source,
                    target = diagonalPath.target,
                    midpointX = (source.x + target.x) / 2,
                    midpointY = (source.y + target.y) / 2,
                    pathData = [source,
                    {   x: source.x,
                        y: midpointY,
                    },
                    {   x: midpointX,
                        y: midpointY,
                    },
                    {   x: target.x,
                        y: midpointY
                    }, target];
                pathData = pathData.map(projection);
                return path(pathData)
            }

            diagonal.projection = function (x) {
                if (!arguments.length) return projection;
                projection = x;
                return diagonal;
            };

            diagonal.path = function (x) {
                if (!arguments.length) return path;
                path = x;
                return diagonal;
            };

            return diagonal;
        };

        function collapse(d) {
            if (d.children) {
              d._children = d.children;
              d._children.forEach(collapse);
              d.children = null;
            }
        }

        // Toggle children on click.
        function click(d) {
          if (d.children) { // expanded
			// see if d is an only child
			if ( d.parent ) {
				if ( 1 == d.parent.children.length ){
					console.log('Expanded node: found an only child');
				}
				console.log('Expanded node has ' + d.parent.children.length + ' siblings');
			}
            d._children = d.children;
            d.children = null;
          } else { // contracted
            console.log('Unexpanded node: found ' + d._children.length + ' children');
            d.children = d._children;
            d._children = null;
          }
          if (d.data) {
          	update_sample_info( d );
          }
          update(d);
        }

        function expand(d) {
          if (d.children) {
            d._children = d.children;
            console.log('found ' + d._children.length + ' children');
			d._children.forEach(expand);
            d.children = null;
          } else {
            d.children = d._children;
            d._children = null;
          }
          update(d);
        }

		function update_sample_info( d ){
			d3.selectAll('.js_sample_details')
				.style('display','none');
			d3.select( '#taxon_oid_' + d.data.taxon_oid )
				.style('display', 'block');
		}

        function update(source) {

          // Compute the new tree layout.
          var nodes = tree.nodes(root).reverse(),
              links = tree.links(nodes);

          // Normalize for fixed-depth.
          nodes.forEach(function(d) { d.y = d.depth * path_length; });

          console.log('Found ' + nodes.length + ' child nodes!');
//           if ( 1 === nodes.length ) {
//             console.log('need to run update again');
//         }
          // Update the nodesâ€¦
          var node = svg.selectAll("g.node")
              .data(nodes, function(d) { return d.id || (d.id = ++i); });

          // Enter any new nodes at the parent's previous position.
          var nodeEnter = node.enter().append("g")
              .attr("class", "node")
              .attr("transform", function(d) {
                    return "translate(" + source.y0 + "," + source.x0 + ")";
              })
              .on('mouseover', tip.show)
              .on('mouseout', tip.hide)
              .on('click', click);

          nodeEnter.append("circle")
              .attr("r", 1e-6)
              .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

          nodeEnter.append("text")
              .attr("x", function(d) { return d.children || d._children ? -5 : 10; })
              .attr("dy", function(d) { return d.children || d._children ? -5 : ".35em"; })
              .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
              .text(function(d) { return d.key || d.taxon_display_name; })
              .style("fill-opacity", 1e-6);

          // Transition nodes to their new position.
          var nodeUpdate = node.transition()
              .duration(duration)
              .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

          nodeUpdate.select("circle")
              .attr("r", 4.5)
              .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

          nodeUpdate.select("text")
              .style("fill-opacity", 1);

          // Transition exiting nodes to the parent's new position.
          var nodeExit = node.exit().transition()
              .duration(duration)
              .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
              .remove();

          nodeExit.select("circle")
              .attr("r", 1e-6);

          nodeExit.select("text")
              .style("fill-opacity", 1e-6);

          // Update the links
          var link = svg.selectAll("path.link")
              .data(links, function(d) { return d.target.id; });

          // Enter any new links at the parent's previous position.
          link.enter().insert("path", "g")
              .attr("class", "link")
              .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
              });

          // Transition links to their new position.
          link.transition()
              .duration(duration)
              .attr("d", diagonal);

          // Transition exiting nodes to the parent's new position.
          link.exit().transition()
              .duration(duration)
              .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
              })
              .remove();

          // Stash the old positions for transition.
          nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
          });
        }

		var margin = {top: 20, right: 20, bottom: 10, left: 40}
		, width = 960 - margin.right - margin.left
		, height = 960 - margin.top - margin.bottom
		, path_length = 80
		, i = 0
		, duration = 750
        , tree = d3.layout.tree()
        	.size([height, width])
		//    .nodeSize([ 15, 50 ])
//            .children(function(d){return d.values;})
//            .value(function(d){return d.key;})

        , diagonal = rightAngleDiagonal()

        , class_types = ['[% results.class_types.join("', '") | replace('_', ' ') %]']

        , tree_w = class_types.length * path_length

        , tip = d3.tip()
            .attr('class', 'd3-tip')
            .direction(function(d){
				if( d.data ){
					return 'w';
				}
            	return 'e';
            })
            .offset([0, 10])
            .html(function(d) {
                if( d.data ){
                	// child node
					return d.taxon_display_name || d.data.taxon_oid;
                }
                if( d.depth > 0 ) {
                    return class_types[ d.depth ] + ': ' + d.key;
                }
                return d.key;
            })
        // results.class_types.join("', '")
        , xScale = d3.scale.ordinal()
            .domain( class_types ) // input
            .rangePoints([ 0, tree_w ] ) // output

        , svg = d3.select("#collapse").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .attr("viewBox", "0 0 960 960")
//            .attr("preserveAspectRatio", "xMinYMin meet")
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
		, data_set = getJson()
		, root = data_set.tree
// 		, root = tree_struct
		;

        root.x0 = height / 2;
        root.y0 = 0;

        update( root );
        svg.call(tip);
        root.children.forEach(collapse);
        update(root);



//         svg.enter()
//             .on('mouseover', tip.show)
//             .on('mouseout', tip.hide)


//        d3.select(self.frameElement)
//            .style("height", "960px")
//            .attr("viewBox", "0 0 1000 1000")
//            .attr("preserveAspectRatio", "xMinYMin meet");

*/

		var json=getJson()
		, tip = d3.tip()
			.attr('class', 'd3-tip')
	//		.rootElement( document.getElementById('partition') )
			.direction(function(d) {
				if ( d.children ) {
					return 'e';
				}
				return 'w';
			})
			.offset([0, 0])
			.html(function(d) {
				if ( d.data && d.data.taxon_display_name) {
					return d.data.taxon_display_name;
				}
				if( d.depth > 0 ) {
					return json.results.class_types[ d.depth-1 ] + ': ' + d.name + ', ' + ( d.value || d.values.length ) + ' samples';
				}
			})

		, container = d3.select("#phylogram")
			.append("svg")
			.call(tip)

		, vis = container.chart("tree.cartesian.diagonal")
			.margin({ top:10,left:10,right:10,bottom:10 })
			.collapsible(1)
			.with_tips( tip )
			.diagonal( 'rightAngle' )
			.levelGap( 80 )
			.sortable("_ASC_");

		d3.selectAll('.js_vis_loading')
			.remove();
		d3.selectAll('.js_sample_details')
			.classed('js_hide',true);

		vis.draw( json.results.tree );

[%	END %]
