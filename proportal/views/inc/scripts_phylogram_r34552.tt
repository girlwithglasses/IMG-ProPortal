[%  scr_arr =
	[
	'/bower/d3/d3.min.js',
	'/bower/d3-tip/index.js',
	'/bower/crossfilter/crossfilter.min.js',
	'/bower/d3.chart/d3.chart.min.js',
	'/js/d3.chart.layout.hierarchy.min.js'

	];
    FOREACH s IN scr_arr;
        '<script type="text/javascript" src="' _ s _ '"></script>';
    END;
%]
<style type="text/css"><!--
    .axis .domain {
        fill: none;
        stroke: black;
        stroke-width: 0;
        shape-rendering: crispEdges;
    }

    .axis .tick text { font-size: .75rem; }
    .grid-background { fill: #eee; }

--></style>
<script type="text/javascript">
(function ready(){
	var res=[%
	IF results.array && results.array.size > 0;
		USE JSON.Escape( convert_blessed => 1 );
		results.array.json;
	ELSE;
		'[]';
	END;
	%],xf=crossfilter(res),tree_struct=d3.nest()
[%          FOREACH c IN results.class_types;
%]            .key( function(d){ return d.[% c %]; } )
[%          END;
%]          .entries(res);
    fn=function(){
        "use strict";

        var rightAngleDiagonal = function () {
            var projection = function (d) {
                return [d.y, d.x];
            },

            path = function (pathData) {
                return "M" + pathData[0] + ' ' + pathData[1] + " " + pathData[2] + " " + pathData[3] + " " + pathData[4];
            };

            function diagonal(diagonalPath, i) {
                var source = diagonalPath.source,
                    target = diagonalPath.target,
                    midpointX = (source.x + target.x) / 2,
                    midpointY = (source.y + target.y) / 2,
                    pathData = [source,
                    {   x: source.x,
                        y: midpointY,
                    },
                    {   x: midpointX,
                        y: midpointY,
                    },
                    {   x: target.x,
                        y: midpointY
                    }, target];
                pathData = pathData.map(projection);
                return path(pathData)
            }

            diagonal.projection = function (x) {
                if (!arguments.length) return projection;
                projection = x;
                return diagonal;
            };

            diagonal.path = function (x) {
                if (!arguments.length) return path;
                path = x;
                return diagonal;
            };

            return diagonal;
        };

        function collapse(d) {
            if (d.children) {
              d._children = d.children;
              d._children.forEach(collapse);
              d.children = null;
            }
        }

        // Toggle children on click.
        function click(d) {
          if (d.children) { // expanded
            d._children = d.children;
            d.children = null;
          } else {
            d.children = d._children;
            d._children = null;
          }
          if (d.data) {
          	update_sample_info( d );
          }
          update(d);
        }

        function expand(d) {
          if (d.children) {
            d._children = d.children;
            d._children.forEach(expand);
            d.children = null;
          } else {
            d.children = d._children;
            d._children = null;
          }
          update(d);
        }

		function update_sample_info( d ){
			d3.select('#info')
				.attr('class','init_done');
			d3.selectAll('.sample_details')
				.style('display','none');
			d3.select( '#taxon_oid_' + d.data.taxon_oid )
				.style('display', 'block');
		}

        function update(source) {

          // Compute the new tree layout.
          var nodes = tree.nodes(root).reverse(),
              links = tree.links(nodes);

          // Normalize for fixed-depth.
          nodes.forEach(function(d) { d.y = d.depth * path_length; });

          console.log('Found ' + nodes.length + ' child nodes!');
//           if ( 1 === nodes.length ) {
//             console.log('need to run update again');
//         }
/**
nodes.forEach(function(d) { //iterate through the nodes
  if(d.parent){ //if the node has a parent
    for(var i = 0, pl=d.parent.children.length; i < pl; i++){ //check parent children
      if(d.parent.children[i].name == d.name){ //find current node
        d.yOffset = i; //index is how far node must be moved down
        d.parentYoffset = d.parent.yOffset; //must also account for parent downset

        if (d.parent.parentYoffset) {
            d.parentYoffset += d.parent.parentYoffset;
        }
      }
    }
  }
  if(d.yOffset === undefined){ d.yOffset = 0; }
  if(d.parentYoffset === undefined){ d.parentYoffset = 0; }
  d.x = (d.yOffset * 40) + (d.parentYoffset * 40) + 20;
  d.y = d.depth * 80;
});
*/

          // Update the nodesâ€¦
          var node = svg.selectAll("g.node")
              .data(nodes, function(d) { return d.id || (d.id = ++i); });

          // Enter any new nodes at the parent's previous position.
          var nodeEnter = node.enter().append("g")
              .attr("class", "node")
              .attr("transform", function(d) {
                    return "translate(" + source.y0 + "," + source.x0 + ")";
              })
              .on('mouseover', tip.show)
              .on('mouseout', tip.hide)
              .on("click", click);

          nodeEnter.append("circle")
              .attr("r", 1e-6)
              .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

          nodeEnter.append("text")
              .attr("x", function(d) { return d.children || d._children ? -5 : 10; })
              .attr("dy", function(d) { return d.children || d._children ? -5 : ".35em"; })
              .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
              .text(function(d) { return d.key || d.taxon_display_name; })
              .style("fill-opacity", 1e-6);

          // Transition nodes to their new position.
          var nodeUpdate = node.transition()
              .duration(duration)
              .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

          nodeUpdate.select("circle")
              .attr("r", 4.5)
              .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

          nodeUpdate.select("text")
              .style("fill-opacity", 1);

          // Transition exiting nodes to the parent's new position.
          var nodeExit = node.exit().transition()
              .duration(duration)
              .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
              .remove();

          nodeExit.select("circle")
              .attr("r", 1e-6);

          nodeExit.select("text")
              .style("fill-opacity", 1e-6);

          // Update the links
          var link = svg.selectAll("path.link")
              .data(links, function(d) { return d.target.id; });

          // Enter any new links at the parent's previous position.
          link.enter().insert("path", "g")
              .attr("class", "link")
              .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
              });

          // Transition links to their new position.
          link.transition()
              .duration(duration)
              .attr("d", diagonal);

          // Transition exiting nodes to the parent's new position.
          link.exit().transition()
              .duration(duration)
              .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
              })
              .remove();

          // Stash the old positions for transition.
          nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
          });
        }


        var margin = {top: 20, right: 20, bottom: 10, left: 40}
        , width = 960 - margin.right - margin.left
        , height = 960 - margin.top - margin.bottom
        , path_length = 80
        , i = 0
        , duration = 750
        , root = tree_struct[0]

        , tree = d3.layout.tree()
            .size([height,width])
        //    .nodeSize([ 15, 50 ])
            .children(function(d){return d.values;})
//            .value(function(d){return d.key;})

        , diagonal = rightAngleDiagonal()

        , class_types = ['[% results.class_types.join("', '") | replace('_', ' ') %]']

        , tree_w = class_types.length * path_length

        , tip = d3.tip()
            .attr('class', 'd3-tip')
            .direction(function(d){
				if( d.data ){
					return 'w';
				}
            	return 'e';
            })
            .offset([0, 10])
            .html(function(d) {
                if( d.data ){
                	// child node
					return d3.select( '#taxon_oid_' + d.data.taxon_oid ).innerHTML;

                }
                if( d.depth > 0 ) {
                    return class_types[ d.depth ] + ': ' + d.key;
                }
                return d.key;
            })
        // results.class_types.join("', '")
        , xScale = d3.scale.ordinal()
            .domain( class_types ) // input
            .rangePoints([ 0, tree_w ] ) // output

        , svg = d3.select("#collapse").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .attr("viewBox", "0 0 960 960")
            .attr("preserveAspectRatio", "xMinYMin meet")
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        svg.selectAll("rect")
            .data(class_types)
            .enter()
            .append("rect")
            .attr( "x", function(d, i) {
                return i * path_length;
            })
            .attr( "y", 0 )
            .attr( "width", path_length )
            .attr( "height", height )
            .attr( "class", 'grid-background' );

        svg.selectAll("text")
            .data(class_types)
            .enter()
            .append("text")
            .text(function(d) {
                return d;
            })
            .attr("text-anchor", "middle")
            .attr("x", function(d, i) {
                return i * path_length + path_length / 2;
            })
            .attr("y", 20);

//         svg.append("g")
//             .attr("class", "axis")  //Assign "axis" class
//             .call( d3.svg.axis()
//                 .scale(xScale)
//                 .orient("top")
//                 .tickSize( -height )
//             );

//         xAxis = d3.svg.axis()
//             .scale(xScale)
//             .orient("bottom");
//         svg.append("g")
//             .call(xAxis);


        root.x0 = height / 2;
        root.y0 = 0;

        update(root);
        svg.call(tip);
        root.children.forEach(collapse);
//        update(root);



//         svg.enter()
//             .on('mouseover', tip.show)
//             .on('mouseout', tip.hide)


//        d3.select(self.frameElement)
//            .style("height", "960px")
//            .attr("viewBox", "0 0 1000 1000")
//            .attr("preserveAspectRatio", "xMinYMin meet");
    };
/*
    var n = cf.groupAll().reduceCount().value();
    console.log('There are ' + n + ' samples.');

    var types = genome_type.group().all();
    var doms = domain.group().all();
    var tree;

    var d = [ genome_type,domain,phylum,ir_class,ir_order,family,clade ];
    var tr = recurse({ xf: cf, d: d, index: 0, tree: { name: 'base', children: [ ] }});

    var blob =

    function recurse( args ){
        var dim,
        xf = args.xf,
        children;
        if( args.index !==args['d'].length){
            dim = args.d[ args.index ];
            children = dim.group().all().map(function(curr,ix,arr){
                console.log( curr );
                var filtered = dim.filter( curr.key );
                // for every member of the group, we want to add name: ..., children: ...
                var kids = recurse({
                    d: this.d,
                    index: this.index+1,
                    tree: this.tree,
                    xf: filtered
                });
                this.tree.push({ name: curr, children: kids });
            }, args);
            args.tree.children = children;
            return args.tree;
        }
    }

*/

	if (document.readyState !== 'loading'){
		fn();
	} else if (document.addEventListener) {
		document.addEventListener('DOMContentLoaded', function(){
			fn();
		});
	} else {
		document.attachEvent('onreadystatechange', function() {
			if (document.readyState !== 'loading'){
				fn();
			}
		});
	}
}());
</script>

